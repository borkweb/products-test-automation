<?php
/**
 * Global namespace functions.
 *
 * This file is auto-generated by the dev/setup/shell-stubs.sh script.
 */

/**
 * Provides functions to run automated tests.
 */

/**
 * Randomly activate some plugins found in the plugin store, in random order and versions.
 *
 * @param int $epochs The number of times to run the random activation.
 *
 * @throws Exception If there's an issue reading the plugin store contents.
 */
function randomly_activate_plugins( $epochs ) {
	$cli               = cli();
	$wordpress_version = check_status_or_exit( $cli( [ 'core', 'version' ] ) )( 'string_output' );

	for ( $i = 1; $i <= $epochs; $i ++ ) {
		$plugins = random_plugins( plugin_store() );

		echo "\nThe following plugins will be activated:\n" . json_encode( $plugins, JSON_PRETTY_PRINT );

		$list = $cli( array_merge( [ 'plugin', 'list', '--format=csv', '--status=active', '--fields=name,version' ] ) );
		check_status_or_exit( $list );

		check_status_or_exit(
			$cli( [ 'plugin', 'deactivate', '--all' ] ),
			"\n\nFatality!\n"
			. the_fatality()
			."\nWordPress version: {$wordpress_version}\n"
			. "\nThe following deactivation context has issues: \n" . implode( "\n", $list( 'output' ) )
		);

		foreach ( $plugins as $plugin ) {
			$plugin_zip = wordpress_container_root_dir(
				'_plugin_store/' . relative_path( plugin_store(), $plugin['zip'] )
			);
			check_status_or_exit( $cli( [ 'plugin', 'install', $plugin_zip, '--force' ] ) );
		}

		$list = $cli( array_merge( [ 'plugin', 'list','--format=csv', '--fields=name,version' ] ) );
		check_status_or_exit( $list );
		the_process_output( $list );

		$activated = [];
		$debug = "\n\nFatality!\n"
		         . the_fatality()
		         ."\nWordPress version: {$wordpress_version}\n"
		         . "\nThe following activation path has issues: \n";

		foreach ( $plugins as $plugin ) {
			$activated[ $plugin['slug'] ] = $plugin['version'];
			$plugin_slug                  = plugin_wordpress_name( $plugin['slug'] );
			$activate                     = $cli( [ 'plugin', 'activate', $plugin_slug ] );
			check_status_or_exit( $activate, $debug . json_encode( $activated, JSON_PRETTY_PRINT ) );
		}
	}
}
/**
 * Functions to colorize and style CLI output.
 */

/**
 * Colorizes a string in a specific color.
 *
 * @param string $string     The string to colorize.
 * @param int    $color_code The string color, or style code, to apply to the string.
 *
 * @return string The style string.
 *
 * @see https://misc.flogisoft.com/bash/tip_colors_and_formatting
 */
function style( $string, $color_code ) {
	return "\033[" . $color_code . "m" . $string . "\033[0m";
}

/**
 * Colorizes a string in light cyan.
 *
 * @param string $string The string to colorize.
 *
 * @return string The colorized string.
 */
function light_cyan( $string ) {
	return style( $string, '1;36' );
}

/**
 * Colorizes a string in magenta.
 *
 * @param string $string The string to colorize.
 *
 * @return string The colorized string.
 */
function magenta( $string ) {
	return style( $string, 35 );
}

/**
 * Colorizes a string in red.
 *
 * @param string $string The string to colorize.
 *
 * @return string The colorized string.
 */
function red( $string ) {
	return style( $string, 31 );
}

/**
 * Colorizes a string in green.
 *
 * @param string $string The string to colorize.
 *
 * @return string The colorized string.
 */
function green( $string ) {
	return style( $string, 32 );
}

/**
 * Colorizes and styles a string.
 *
 * Colors and styles placeholders should have the `<color>...</color>` format.
 * Nested styles will not work.
 *
 * @param string $string The string to style and colorize.
 *
 * @return string The styled and colorized string.
 */
function colorize( $string ) {
	$result = preg_replace_callback(
		'/<(?<style>[\\w]+)>(?<string>.*?)<\\/\\k<style>>/us',
		static function ( array $m ) {
			$function_name = '\\Tribe\\Test\\' . $m['style'];
			if ( ! function_exists( $function_name ) ) {
				return $m['string'];
			}

			return call_user_func( $function_name, $m['string'] );
		},
		$string
	);

	return $result;
}
/**
 * Utilities and functions to interact w/ the nightly build service.
 */

/**
 * Returns the base nightly build service URL.
 *
 * @return string The base nightly build service URL.
 */
function nightly_api_url() {
	return 'https://utility.tri.be/nightly.php';
}

/**
 * Returns the nightly build secret, fetched from the nightly builds API.
 *
 * @return string|null The nightly build secret string.
 */
function nightly_secret( $licenses_file = null ) {
	parse_license_file( $licenses_file );

	return getenv( 'NIGHTLY_SECRET' );
}

/**
 * Fetches and returns the nightly builds timestamp
 *
 * @param string      $branch        The branch to fetch the build timestamp for.
 * @param string|null $licenses_file The licenses file to use to read the secret, or `null` to read the secret from
 *                                   the env vars.
 *
 * @return string The nightly build timestamp for the branch.
 */
function nightly_build_timestamp( $branch, $licenses_file = null ) {
	$response = curl_get( nightly_api_url(), [
		'timestamp' => '1',
		'branch'    => $branch,
		'key'       => nightly_secret( $licenses_file ),
	] );

	$decoded = json_decode( $response, true );

	if ( false === $decoded || ! isset( $decoded['timestamp'] ) ) {
		echo( 'Could not decode nightly build JSON response: ' . $response );
		exit( 1 );
	}

	return $decoded['timestamp'];
}

/**
 * Fetches and returns the available nightly builds for a branch.
 *
 * @param string      $branch        The name of the branch to fetch the nightly builds information for.
 * @param string|null $licenses_file The licenses file to use to read the secret, or `null` to read the secret from
 *                                   the env vars.
 *
 * @return array The decoded response.
 */
function nightly_builds( $branch, $licenses_file = null ) {
	$key      = nightly_secret( $licenses_file );

	if ( empty( $key ) ) {
		echo "\nNightly secret not found or not defined; is the NIGHTLY_SECRET env var set?";
		exit( 1 );
	}

	$response = curl_get( nightly_api_url(), [
		'branch' => $branch,
		'key'    => $key,
	] );

	$decoded = json_decode( $response, true );

	if ( false === $decoded ) {
		echo( "\nCould not decode nightly builds JSON response: " . $response );
		exit( 1 );
	}

	return $decoded;
}
/**
 * Plugin related functions for the build PHP scripts.
 */

/**
 * Returns the list of Modern Tribe .org plugins.
 *
 * @return array<string> A list of Modern Tribe .org hosted WordPress plugin slugs.
 */
function org_plugins() {
	return [
		'the-events-calendar',
		'event-tickets',
		'advanced-post-manager',
		'image-widget',
	];
}

/**
 * Returns the list of Modern Tribe premium plugins.
 *
 * @return array<string> A list of Modern Tribe premium WordPress plugin slugs.
 */
function premium_plugins() {
	return array_keys( premium_plugins_license_keys_map() );
}

/**
 * Returns the list of all Modern Tribe plugins, .org and premium.
 *
 * @return array<string> A list of all Modern Tribe WordPress plugin slugs.
 */
function all_plugins() {
	return array_merge( org_plugins(), premium_plugins() );
}

/**
 * Returns a map relating each premium plugin slug to the expected name of the env var that should contain its license.
 *
 * @return array<string,string> The plugin slug to expected license env var name map.
 */
function premium_plugins_license_keys_map() {
	return [
		'events-community'         => 'COMMUNITY_EVENTS_LICENSE',
		'events-community-tickets' => 'COMMUNITY_TICKETS_LICENSE',
		'tribe-edd-tickets'        => 'EDD_TICKETS_LICENSE',
		'events-elasticsearch'     => 'EVENTS_ELASTICSEARCH_LICENSE',
		'event-tickets-plus'       => 'EVENT_TICKETS_PLUS_LICENSE',
		'tribe-eventbrite'         => 'EVENTBRITE_TICKETS_LICENSE',
		'events-calendar-pro'      => 'EVENTS_CALENDAR_PRO_LICENSE',
		'events-facebook-importer' => 'EVENTS_FACEBOOK_IMPORTER_LICENSE',
		'tribe-filterbar'          => 'FILTERBAR_LICENSE',
		'tribe-ical-importer'      => 'ICAL_IMPORTER_LICENSE',
		'image-widget-plus'        => 'IMAGE_WIDGET_PLUS_LICENSE',
		'tribe-shopptickets'       => 'SHOPPTICKETS_LICENSE',
		'tribe-wootickets'         => 'WOOTICKETS_LICENSE',
		'tribe-wpectickets'        => 'WPECTICKETS_LICENSE'
	];
}

/**
 * Returns a map relating each SaaS slug to the expected name of the env var that should contain its license.
 *
 * @return array<string,string> The SaaS slug to expected license env var name map.
 */
function saas_license_keys_map() {
	return [
		'event-aggregator' => 'EVENT_AGGREGATOR_LICENSE',
		'promoter'         => 'PROMOTER_LICENSE',
	];
}

/**
 * Fetches and returns the last n versions of the specified plugins, both .org and premium plugins.
 *
 * @param callable $args A closure to provide the arguments.
 *
 * @return array<string,array> An array of each plugin slug versions.
 */
function plugin_versions( callable $args ) {
	$plugins         = validate_plugins( parse_list( $args( 'plugins', all_plugins() ) ) );
	$number_versions = $args( 'number_versions' );

	$required_org_plugins     = array_intersect( $plugins, org_plugins() );
	$required_premium_plugins = array_intersect( $plugins, premium_plugins() );
	$org_plugins_versions     = org_plugins_versions( $required_org_plugins, $number_versions );
	$premium_plugins_versions = premium_plugin_versions( $required_premium_plugins, $number_versions );

	return $org_plugins_versions + $premium_plugins_versions;
}

/**
 * Fetches and returns the last n versions of the specified .org plugins.
 *
 * @param array<string> $required_plugins A list of the required .org hosted plugins slugs.
 * @param int           $number_versions  The number of last versions to fetch for each plugin.
 *
 * @return array<string,array> An array of each plugin slug versions.
 */
function org_plugins_versions( array $required_plugins = [], $number_versions = 3 ) {
	if ( count( $required_plugins ) === 0 ) {
		return [];
	}

	echo "\n\nFetching .org plugins versions...";
	$plugin_api_url        = 'https://api.wordpress.org/plugins/info/1.2/';
	$org_plugins_json_info = curl_get( $plugin_api_url, [
		'action'  => 'plugin_information',
		'request' =>
			[
				'slugs' => $required_plugins
			]
	] );

	$decoded_org_info = json_decode( $org_plugins_json_info, true );

	if ( false === $decoded_org_info ) {
		echo '.org plugin(s) information could not be decoded; ' . json_last_error_msg();
		exit( 1 );
	}

	$org_plugins_versions = array_combine(
		$required_plugins,
		array_map( static function ( $plugin_slug ) use ( $number_versions, $decoded_org_info ) {
			if ( ! isset( $decoded_org_info[ $plugin_slug ] ) ) {
				echo "\n.org plugin information for {$plugin_slug} is missing.";
				exit( 1 );
			}
			$versions = $decoded_org_info[ $plugin_slug ]['versions'];
			// Versions come in older to newer order, let's reverse them.
			$versions = array_reverse( $versions, true );
			// The latest version, now first, is trunk, drop it as it's a duplicate of the last tagged one.
			// Keep only the last n.
			$versions = array_slice( $versions, 1, $number_versions );

			// The version array format is [<version> => <zip_url>].
			return $versions;
		}, $required_plugins )
	);

	return $org_plugins_versions;
}

/**
 * Fetches and returns the last n versions of the specified premium plugins.
 *
 * @param array<string> $required_plugins A list of the required premium plugins slugs.
 * @param int           $number_versions  The number of last versions to fetch for each plugin.
 *
 * @return array<string,array> An array of each plugin slug versions.
 */
function premium_plugin_versions( array $required_plugins = [], $number_versions = 3 ) {
	if ( count( $required_plugins ) === 0 ) {
		return [];
	}

	echo "\n\nFetching premium plugins versions...";

	$plugins_data = curl_get( pue_url( '/plugins' ) );

	$decoded = json_decode( $plugins_data, true );

	if ( false === $decoded || ! isset( $decoded['plugins'] ) ) {
		echo "\nPUE /plugins response was malformed: \n" . $plugins_data;
		exit( 1 );
	}

	$plugins = $decoded['plugins'];

	$required_plugins_data = array_filter( $plugins, static function ( array $plugin_data ) use ( $required_plugins ) {
		return isset( $plugin_data['plugin_slug'] ) && in_array( $plugin_data['plugin_slug'], $required_plugins,
				true );
	} );

	if ( empty( $required_plugins_data ) ) {
		echo "\nFailed to fetch information for all required premium plugins: " .
		     json_encode( $required_plugins, JSON_PRETTY_PRINT );
		exit( 1 );
	}

	$versions     = array_column( $required_plugins_data, 'allowed_versions' );
	$plugin_slugs = array_column( $required_plugins_data, 'plugin_slug' );

	$required_plugins_versions = array_combine(
		$plugin_slugs,
		array_map( static function ( array $plugin_versions, $plugin_slug ) use ( $number_versions ) {
			// Invert to have latest versions first.
			$plugin_versions = array_reverse( $plugin_versions );
			// Keep the last n.
			$plugin_versions = array_slice( $plugin_versions, 0, $number_versions );
			// Walk the versions to build a [ <version> => <url> ] map.
			$plugin_versions = array_combine(
				array_column( $plugin_versions, 'version' ),
				array_column( $plugin_versions, 'plugin_download_url' )
			);

			// Append the correct license key to each plugin download URL.
			array_walk( $plugin_versions, static function ( &$plugin_download_url ) use ( $plugin_slug ) {
				$plugin_download_url .= '&key=' . license_key( $plugin_slug );
			} );

			return $plugin_versions;
		}, $versions, $plugin_slugs )
	);

	return $required_plugins_versions;
}

/**
 * Returns the absolute path, on the host machine, to the directory that contains the downloaded plugins.
 *
 * The function will create the directory first, if it does not exist.
 *
 * @param string $path A relative path to append to the current plugin store absolute path.
 *
 * @return string The absolute path, on the host machine, to the directory that contains the downloaded plugins
 */
function plugin_store($path = '') {
	$plugin_store = getcwd() . '/dev/test/_plugin_store';
	if ( ! is_dir( $plugin_store ) && ! mkdir( $plugin_store, 0777, true ) && ! is_dir( $plugin_store ) ) {
		printf( "\nPlugin store directory %s could not be created.", $plugin_store );
		exit( 1 );
	}

	return empty( $path )
		? $plugin_store
		: rtrim( $plugin_store, '\\/' ) . DIRECTORY_SEPARATOR . ltrim( $path, '\\/' );
}

/**
 * Returns the absolute path, on the host machine, to a plugin zip file provided its name (slug) and version.
 *
 * @param string $name    The plugin slug or name.
 * @param string $version The version to return the zip file path for.
 *
 * @return string The absolute path, on the host machine, to the plugin zip file.
 */
function plugin_zip_file( $name, $version ) {
	$path = plugin_store() . '/' . $name . '-' . $version . '.zip';
	if ( ! file_exists( $path ) ) {
		echo "\nPlugin zip file ${path} does not exist.";
		exit( 1 );
	}

	return $path;
}

/**
 * Installs a plugin in a specific version, overriding any previously installed version, from the plugin store.
 *
 * @param string $name    The name of the plugin to install.
 * @param string $version The version of the plugin to install.
 */
function install_plugin( $name, $version ) {
	$plugin_zip = wordpress_container_root_dir(
		'_plugin_store/' . relative_path( plugin_store(), plugin_zip_file( $name, $version ) )
	);
	check_status_or_exit( cli()( [ 'plugin', 'install', $plugin_zip, '--force', '--debug' ] ) )( 'string_output' );
}

/**
 * Validates the required plugin slugs, to make sure all are either .org or premium valid slugs.
 *
 * @param array<string> $plugins The plugin slugs to validate.
 *
 * @return array<string> The list of plugins, if valid.
 */
function validate_plugins( $plugins ) {
	$not_plugins = array_diff( $plugins, all_plugins() );

	if ( count( $not_plugins ) ) {
		echo "\nThe following plugins are not supported: \n" . json_encode( $not_plugins, JSON_PRETTY_PRINT );
		echo "\nSupported plugins are: \n" . json_encode( all_plugins(), JSON_PRETTY_PRINT );
		exit ( 1 );
	}

	return $plugins;
}

/**
 * Returns a premium plugin license key, reading it from the environment.
 *
 * @param string $plugin_slug The slug of the premium plugin to read the license key for.
 *
 * @return string The premium plugin license key.
 */
function license_key( $plugin_slug ) {
	$map = premium_plugins_license_keys_map();

	if ( ! isset( $map[ $plugin_slug ] ) ) {
		echo "\nLicense key var for {$plugin_slug} is not supported.";
		exit( 1 );
	}

	$env_var     = $map[ $plugin_slug ];
	$license_key = getenv( $env_var );

	if ( empty( $license_key ) ) {
		echo "\nLicense key for {$plugin_slug} ({$env_var}) is not a set env var or is empty.";
		exit( 1 );
	}

	return $license_key;
}

/**
 * Downloads, in the plugin store directory, the specified plugin versions.
 *
 * @param array<string,array> $plugin_versions A map of plugin slugs and the required versions to download.
 */
function download_plugin_versions( array $plugin_versions ) {
	$debug_info = array_map( 'array_keys', $plugin_versions );
	echo "\n\n";
	echo "The following plugin versions will be downloaded: \n"
	     . json_encode( $debug_info, JSON_PRETTY_PRINT );
	echo "\n";

	foreach ( $plugin_versions as $plugin => $versions ) {
		foreach ( $versions as $version => $archive_url ) {
			$dest = plugin_store() . '/' . $plugin . '-' . $version . '.zip';
			echo "\nDownloading ${plugin} version {$version} to {$dest}...\n";
			$command = "curl -L \"{$archive_url}\" > \"{$dest}\"";
			exec( $command, $output, $status );

			if ( 0 !== (int) $status ) {
				echo "\nFailed download: {$archive_url}; \n" . implode( "\n", $output );
				exit( 1 );
			}
		}
	}
}

/**
 * Returns a list of random plugins versions and files, parsing the content of the plugin store.
 *
 * @param string $dir The plugin store directory path.
 *
 * @return array<string,array> The random list of picked plugins and version information.
 *
 * @throws Exception If there's an issue reading the plugin store contents.
 */
function random_plugins( $dir ) {
	$available_zips_iterator = new CallbackFilterIterator(
		new \FilesystemIterator( $dir, FilesystemIterator::SKIP_DOTS ),
		static function ( SplFileInfo $f ) {
			// Either a semantic version or the nightly/dev hash.
			$plugin_zip_pattern = '/[\\w_-]+-([0-9\\.]+|dev-[\\w]+)\\.zip$/uis';

			return $f->isFile() && preg_match( $plugin_zip_pattern, $f->getBasename() );
		}
	);

	$available_zips = iterator_to_array( $available_zips_iterator );

	if ( 0 === count( $available_zips ) ) {
		echo "\nNo plugin zips available";
		exit( 1 );
	}

	$by_slug = array_reduce( $available_zips, static function ( array $map, SplFileInfo $f ) {
		$plugin_zip_pattern = '/(?<slug>[\\w_-]+)-(?<version>([0-9\\.]+|dev-[\\w]+))$/uis';
		preg_match( $plugin_zip_pattern, $f->getBasename( '.zip' ), $m );

		if ( ! isset( $m['slug'], $m['version'] ) ) {
			echo "\nPlugin file {$f->getPathname()} has a malformed name pattern.";
			exit( 1 );
		}

		$slug    = $m['slug'];
		$version = $m['version'];

		if ( isset( $map[ $slug ] ) ) {
			$map[ $slug ][ $version ] = $f->getPathname();
		} else {
			$map[ $slug ] = [ $version => $f->getPathname() ];
		}

		return $map;
	}, [] );

	// Pick a random number of plugins.
	$number = max( 2, random_int( 1, count( array_keys( $by_slug ) ) ) );

	// Pick n random plugins in random order.
	$slugs = array_rand_keys( array_keys( $by_slug ), $number );

	$picks = [];
	foreach ( $slugs as $slug ) {
		$version = array_rand( $by_slug[ $slug ], 1 );
		$picks[] = [
			'slug'    => $slug,
			'version' => $version,
			'zip'     => $by_slug[ $slug ][ $version ],
		];
	}

	return $picks;
}

/**
 * Maps each plugin slug, from the zip/repo, to its WordPress name, this is the name the plugin will be identified with
 * by WordPress.
 *
 * @param string $plugin_slug The slug of the plugin to return the WordPress name for.
 *
 * @return string The WordPress name of the plugin.
 */
function plugin_wordpress_name( $plugin_slug ) {
	$map = [
		// Release zips.
		'the-events-calendar'      => 'the-events-calendar',
		'event-tickets'            => 'event-tickets',
		'advanced-post-manager'    => 'advanced-post-manager',
		'events-community'         => 'the-events-calendar-community-events',
		'events-community-tickets' => 'the-events-calendar-community-events-tickets',
		'events-elasticsearch'     => 'events-elasticsearch',
		'event-tickets-plus'       => 'event-tickets-plus',
		'tribe-eventbrite'         => 'the-events-calendar-eventbrite-tickets',
		'events-calendar-pro'      => 'events-calendar-pro',
		'events-facebook-importer' => 'the-events-calendar-facebook-importer',
		'tribe-filterbar'          => 'the-events-calendar-filterbar',
		'tribe-ical-importer'      => 'the-events-calendar-ical-importer',
		'image-widget'             => 'image-widget',
		'image-widget-plus'        => 'image-widget-plus',
		// Nightly builds.
		'events-eventbrite'        => 'the-events-calendar-eventbrite-tickets',
		'events-pro'               => 'events-calendar-pro',
		'events-facebook'          => 'the-events-calendar-facebook-importer',
		'events-filterbar'         => 'the-events-calendar-filterbar',
		'events-ical-importer'     => 'the-events-calendar-ical-importer',
	];

	return isset( $map[ $plugin_slug ] ) ? $map[ $plugin_slug ] : $plugin_slug;
}

/**
 * Returns a map of the available plugins, and their available nightly builds, for a branch.
 *
 * @param callable $args A closure providing the call arguments.
 *
 * @return array<string,array> A map of each plugin and the available nightly builds.
 */
function plugin_nightly_builds( callable $args ) {
	$branch_nightly_builds = nightly_builds( $args( 'branch' ), $args( 'licenses_file' ) );

	foreach ( $branch_nightly_builds as $branch => $branch_builds ) {
		foreach ( $branch_builds as $plugin_slug => $build_data ) {
			if ( ! empty( $build_data['build_error'] ) ) {
				continue;
			}

			if ( ! isset( $build_data['download_url'], $build_data['build_hash'] ) ) {
				continue;
			}

			$download_url = $build_data['download_url'];
			$version      = 'dev-' . $build_data['build_hash'];

			if ( isset( $map[ $plugin_slug ] ) ) {
				$map[ $plugin_slug ][ $version ] = $download_url;
			} else {
				$map[ $plugin_slug ] = [ $version => $download_url ];
			}
		}
	}

	return $map;
}

/**
 * Returns a list of the available plugins in the `dev/_plugins` directory.
 *
 * @return array<string,SplFileInfo> A map of each directory in the `dev/_plugins` directory to the corresponding file
 *                                   information.
 */
function dev_plugins() {
	$dev_plugins     = [];
	$options         = FilesystemIterator::SKIP_DOTS | FilesystemIterator::UNIX_PATHS;
	$dev_plugins_dir = new CallbackFilterIterator( new FilesystemIterator( dev( '_plugins' ), $options ),
		static function ( SplFileInfo $file ) {
			return $file->isDir();
		}
	);

	$allowed_subdirs = [ 'common' ];
	foreach ( iterator_to_array( $dev_plugins_dir ) as $key => $value ) {
		$basename                 = basename( $key );
		$dev_plugins[ $basename ] = $value;
		foreach ( $allowed_subdirs as $subdir ) {
			$subdir_path = $value . '/' . $subdir;
			if ( file_exists( $subdir_path ) ) {
				$dev_plugins[ $basename . '/' . $subdir ] = $subdir_path;
			}
		}
	}

	return $dev_plugins;
}
/**
 * Process related files and functions.
 */

/**
 * Runs a process and returns a closure that allows getting the status or output from it.
 *
 * @param string $command The command to run, in string format.
 *
 * @return \Closure A closure that will take will return the process status, output as an array or output as a
 *                 string using the keys 'status', 'output', 'string_output' respectively.
 */
function process( $command ) {
	debug( "Executing command: {$command}\n" );

	exec( escapeshellcmd( $command ), $output, $status );

	return static function ( $what = null ) use ( $output, $status ) {
		if ( null === $what || 'status' === $what ) {
			return (int) $status;
		}

		if ( 'string_output' === $what ) {
			return trim( implode( PHP_EOL, $output ) );
		}

		return $output;
	};
}

/**
 * Runs a process in realtime, displaying its output.
 *
 * @param string $command The command to run.
 *
 * @return int The process exit status, `0` means ok.
 */
function process_realtime( $command ) {
	debug( "Executing command: {$command}" );

	echo PHP_EOL;

	passthru( escapeshellcmd( $command ), $status );

	return (int) $status;
}

/**
 * Unsets the PHP max execution time allowing the PHP thread to run without time limit.
 */
function remove_time_limit() {
	change_time_limit( 0 );
}

/**
 * Sets the time limit for the current PHP thread.
 *
 * This function acts as a wrapper for the `max_execution_time` setting of PHP.
 *
 * @param int $time_limit The time limit to set, setting the value to `0` will remove the execution time limit.
 */
function change_time_limit( $time_limit = 0 ) {
	ini_set( 'max_execution_time', $time_limit );
}

/**
 * Checks the status of a process, or `exit`s.
 *
 * @param callable   $process The process to check.
 * @param mixed|null $message An optional message to print after the output, if the message is not a string, then
 *                            the message data will be encoded and printed using JSON.
 *
 * @return \Closure The process handling closure.
 */
function check_status_or_exit( callable $process, $message = null ) {
	if ( 0 !== (int) $process( 'status' ) ) {
		echo "\nProcess status is not 0, output: \n\n" . implode( "\n", $process( 'output' ) );
		if ( null !== $message ) {
			echo "\nDebug:\n" .
			     ( is_string( $message ) ? $message : json_encode( $message, JSON_PRETTY_PRINT ) ) .
			     "\n";
		}
		exit ( 1 );
	}

	return $process;
}

/**
 * Checks the status of a process on a timeout, or `exit`s.
 *
 * @param callable $process The process to check.
 * @param int      $timeout The timeout, in seconds.
 *
 * @return \Closure The process handling closure.
 */
function check_status_or_wait( callable $process, $timeout = 10 ) {
	$end = time() + (int) $timeout;
	while ( time() <= $end ) {
		if ( 0 !== (int) $process( 'status' ) ) {
			echo "\nProcess status is not 0, waiting...";
			sleep( 2 );
		} else {
			return $process;
		}
	}

	return check_status_or_exit( $process );
}

/**
 * PUE related functions.
 */

/**
 * Return the complete URL to the PUE service for an endpoint and arguments.
 *
 * @param string        $endpoint   The endpoint to fetch the information for.
 * @param array<string> $query_args The list of query arguments to append to the service URL.
 *
 * @return string The complete, and hashed w/ secret, PUE service URL.
 */
function pue_url( $endpoint, array $query_args = [] ) {
	$pue_signed_secret = getenv( 'PUE_SIGNED_SECRET' );
	$pue_url           = getenv( 'PUE_URL' );

	if ( empty( $pue_signed_secret ) ) {
		echo "\nThe PUE_SIGNED_SECRET environment variable is either not defined or empty.";
		exit( 1 );
	}

	if ( empty( $pue_url ) ) {
		echo "\nThe PUE_URL environment variable is either not defined or empty.";
		exit( 1 );
	}

	$query_args = array_map( 'strval', $query_args );

	// Add timestamp (inflate by 4hrs).
	$query_args['timestamp'] = (string) ( time() + ( 60 * 60 * 4 ) );

	// Sign the request
	ksort( $query_args );
	$encoded_data       = json_encode( $query_args );
	$query_args['hash'] = hash( 'sha256', $encoded_data . $pue_signed_secret );

	return rtrim( $pue_url, '/' ) . '/' . ltrim( $endpoint, '/' ) . '?' . http_build_query( $query_args );
}

/**
 * Utility functions for the build PHP scripts.
 */

/**
 * Curried argument fetcher to avoid global spamming.
 *
 * @param array<string>     $map    The list of arguments to fetch from `$argv`.
 * @param array<mixed>|null $source The arguments source array, if not specified, then the global `$argv` array will
 *                                  be used.
 * @param int               $offset Start reading arguments from this position, usually `1` for the main args and `0`
 *                                  when reading an array of sub-arguments.
 *
 * @return \Closure The arg fetching closure.
 */
function args( array $map = [], array $source = null, $offset = 1 ) {
	if ( null === $source ) {
		// If the source is not specified, then read the arguments from the global CLI arguments array.
		global $argv;
		$source = $argv;
	}

	$full_map        = [];
	$parsed_variadic = false;
	foreach ( $map as $position => $key ) {
		if ( $key === '...' && $parsed_variadic ) {
			throw new \InvalidArgumentException( 'The ... key must be the last in the arguments map!' );
		}

		if ( '...' === $key ) {
			$full_map [ $key ] = array_slice( $source, $position + $offset );
			$parsed_variadic   = true;
			continue;
		}

		$full_map[ $key ] = isset( $source[ $position + $offset ] ) ? $source[ $position + $offset ] : null;
	}

	return static function ( $key, $default = null ) use ( $full_map ) {
		return null !== $full_map[ $key ] ? $full_map[ $key ] : $default;
	};
}

/**
 * Uses curl to fire a GET request to a URL.
 *
 * @param string $url The URL to fire the request to.
 * @param array  $query_args
 *
 * @return string  The curl response.
 */
function curl_get( $url, array $query_args = [] ) {
	$full_url = $url . ( strpos( $url, '?' ) === false ? '?' : '' ) . http_build_query( $query_args );

	$curl_handle = curl_init();
	curl_setopt( $curl_handle, CURLOPT_URL, $full_url );
	curl_setopt( $curl_handle, CURLOPT_HEADER, 0 );
	curl_setopt( $curl_handle, CURLOPT_RETURNTRANSFER, true );
	curl_setopt( $curl_handle, CURLOPT_TIMEOUT, 10 );
	curl_setopt( $curl_handle, CURLOPT_FOLLOWLOCATION, true );

	if ( ! $result = curl_exec( $curl_handle ) ) {
		echo "\nFailed to process curl request.";
		echo "\nError: " . curl_error( $curl_handle );
		exit( 1 );
	}

	curl_close( $curl_handle );

	return $result;
}

/**
 * Parses a provided license file and puts into the env, if any.
 *
 * @param string|null $licenses_file The path to the licenses file to parse or `null` to read licenses from the
 *                                   environment variables.
 */
function parse_license_file( $licenses_file = null ) {
	if ( null !== $licenses_file ) {
		load_env_file( $licenses_file );
	} else {
		echo "\nLicenses file not specified, licenses will be read from environment.";
	}
}

/**
 * Loads the contents of an env file in the environment.
 *
 * @param string $env_file The env file to read the contents of.
 */
function load_env_file( $env_file ) {
	$env_lines = read_env_file( $env_file );

	foreach ( $env_lines as $key => $value ) {
		putenv( "${key}={$value}" );
	}
}

/**
 * Reads the content of an environment file into an array.
 *
 * @param string $env_file The environment file to parse.
 *
 * @return array<string,string> A map of keys and values parsed from the env file.
 */
function read_env_file( $env_file ) {
	if ( ! file_exists( $env_file ) ) {
		echo "\nenv file ${env_file} does not exist.";
		exit( 1 );
	}

	$lines     = array_filter( explode( "\n", file_get_contents( $env_file ) ) );
	$env_lines = [];
	foreach ( $lines as $env_line ) {
		if ( ! preg_match( '/^(?<key>[^=]+)=(?<value>.*)$/', $env_line, $m ) ) {
			continue;
		}
		$env_lines[ $m['key'] ] = $m['value'];
	}

	return $env_lines;
}

/**
 * Parses a string list into an array.
 *
 * @param array|string $list The list to parse.
 * @param string       $sep  The separator to use.
 *
 * @return array The parsed list.
 */
function parse_list( $list, $sep = ',' ) {
	if ( is_string( $list ) ) {
		$list = array_filter( preg_split( '/\\s*' . preg_quote( $sep ) . '\\s*/', $list ) );
	}

	return $list;
}

/**
 * Like `array_rand`, but returns the actual array key, not the index.
 *
 * @param array $array   The array to get the random keys for.
 * @param int   $num_req The required number of keys.
 *
 * @return array A set of random keys from the array.
 */
function array_rand_keys( array $array, $num_req = 1 ) {
	$picks = array_rand( $array, $num_req );

	return array_keys( array_intersect( array_flip( $array ), $picks ) );
}

/**
 * Returns the relative path of a file, from a root.
 *
 * @param string $root The root file to build the relative path from.
 * @param string $file The file, or directory, to return the relative path for.
 *
 * @return string The file path relative to the root directory.
 */
function relative_path( $root, $file ) {
	$root          = rtrim( $root, '\\/' );
	$relative_path = str_replace( $root, '', $file );

	return ltrim( $relative_path, '\\/' );
}

/**
 * Returns the user UID reading it from the environment, or from the output of a command if not set.
 *
 * @return string The current user ID.
 */
function uid() {
	$uid = getenv( 'UID' );

	if ( false === $uid && in_array( os(), [ 'Linux', 'macOS' ] ) ) {
		$uid = check_status_or_exit( process( 'id -u' ) )( 'string_output' );
	}

	return false !== $uid ? $uid : 0;
}

/**
 * Returns the user GID reading it from the environment, or from the output of a command if not set.
 *
 * @return string The current user group ID.
 */
function gid() {
	$gid = getenv( 'GID' );

	if ( false === $gid && in_array( os(), [ 'Linux', 'macOS' ] ) ) {
		$gid = check_status_or_exit( process( 'id -g' ) )( 'string_output' );
	}

	if ( false === $gid ) {
		$gid = 0;
		putenv( 'GID=0' );
	}

	return false !== $gid ? $gid : 0;
}

/**
 * Sets up the user id and group in the environment.
 *
 * @param bool $reset Whether to refetch and reset the user id and group or not.
 */
function setup_id( $reset = false ) {
	if (
		false === $reset
		&& false !== getenv( 'DOCKER_RUN_UID' )
		&& false !== getenv( 'DOCKER_RUN_GID' )
	) {
		return;
	}
	putenv( 'DOCKER_RUN_UID=' . uid() );
	putenv( 'DOCKER_RUN_GID=' . gid() );
	putenv( 'DOCKER_RUN_SSH_AUTH_SOCK=' . ssh_auth_sock() );
}

/**
 * Echoes a process output.
 *
 * @param callable $process the process to output from.
 */
function the_process_output( callable $process ) {
	echo "\n" . implode( "\n", $process( 'output' ) );
}

/**
 * Clarifies the nature of the issue.
 *
 * @return string Helpful ASCII art.
 */
function the_fatality() {
	return '
                       _..----------.._                       
                  .-=""        _       ""=-.                  
               .-"    _.--""j _\""""--._    "-.               
            .-"  .-i   \   / / \;       ""--.  "-.            
          .\'  .-"  : ( "  : :                "-.  `.          
        .\'  .\'      `.`.   \ \                  `.  `.        
       /  .\'      .---" ""--`."-./\'---.           `.  \       
      /  /      .\'                    \'-.           \  \      
     /  /      /                         `.          \  \     
    /  /      /                  ,--._   (            \  \    
   ,  /    \'-\')                  `---\'    `.           \  .   
  .  :      .\'                              "-._.-.     ;  ,  
  ;  ;     /            :;         ,-"-.    ,--.   )    :  :  
 :  :     :             ::        :_    "-. \'-\'   `,     ;  ; 
 |  |     :              \\     .--."-.    `._ _   ;     |  | 
 ;  ;     :              / "---"    "-."-.    l.`./      :  : 
:  :      ;             :              `. "-._; \         ;  ;
;  ;      ;             ;                `..___/\\        :  :
;  ;      ;             :                        \\    _  :  :
:  :     /              \'.                        ;;.__)) ;  ;
 ;  ; .-\'                 "-...______...--._      ::`--\' :  : 
 |  |  `--\'\                                "-.    \`._, |  | 
 :  :       \                                  `.   "-"  ;  ; 
  ;  ;       `.                                  \      :   \' 
  \'  :        ;                                   ;     ;  \'  
   \'  \    _  : :`.                               :    /  /   
    \  \   \`-\' ; ; ._                             ;  /  /    
     \  \   `--\'  : ; "-.                          : /  /     
      \  \        ;/     \                         ;/  /      
       \  `.              ;                        \'  /       
        `.  "-.   bug    /                          .\'        
          `.   "-..__..-"                         .\'          
            "-.                                .-"            
               "-._                        _.-"               
                   """---...______...---"""	
	';
}

/**
 * Returns the host machine IP address as reachable from the containers.
 *
 * The way the host machine IP address is fetched will vary depending on the Operating System the function runs on.
 *
 * @param string $os The operating system to get the host machine IP address for.
 *
 * @return string The host machine IP address or host name (e.g. `host.docker.internal` on macOS or Windows), or
 *                an empty string to indicate the host machine IP address could not be obtained.
 */
function host_ip( $os = 'Linux' ) {
	switch ( $os ) {
		case 'Linux':
			$command = "$(ip route | grep docker0 | awk '{print $9}')";
			exec( $command, $host_ip_output, $host_ip_status );
			if ( 0 !== (int) $host_ip_status ) {
				echo "<red>Cannot get the host machine IP address using '${command}'" .
				     $host_ip = false;
			}
			$host_ip = $host_ip_output[0];
			break;
		default:
			$host_ip = 'host.docker.internal';
	}

	return $host_ip;
}

/**
 * Returns whether the current running context is a Continuous Integration one or not.
 *
 * @return bool Whether the current running context is a Continuous Integration one or not.
 */
function is_ci() {
	$env_vars = [
		'CI',
		'TRAVIS_CI',
		'CONTINUOUS_INTEGRATION',
		'GITHUB_ACTION',
	];
	foreach ( $env_vars as $key ) {
		if ( (bool) getenv( $key ) ) {
			return true;
		}
	}

	return false;
}

// Whether the current run context is a `tric` binary one or not.
function is_tric() {
	$env_vars = [
		'TRIBE_TRIC',
		'TRIC',
	];
	foreach ( $env_vars as $key ) {
		if ( (bool) getenv( $key ) ) {
			return true;
		}
	}

	return false;
}

/**
 * Returns the current run context.
 *
 * @return string The current run context, one of `ci`, `tric` or `default`.
 */
function run_context() {
	if ( is_ci() ) {
		return 'ci';
	}
	if ( is_tric() ) {
		return 'tric';
	}

	return 'default';
}

/**
 * Returns the path to the `dev` directory or to a sub-path in it.
 *
 * @param string $path The path to append to the absolute path of the `dev` directory.
 *
 * @return string The absolute path to the `dev` directory or a to a sub-directory of it.
 */
function dev( $path = '' ) {
	$dev = dirname( dirname( __DIR__ ) );

	return empty( $path ) ? $dev : $dev . DIRECTORY_SEPARATOR . ltrim( $path, '\\/' );
}

/**
 * Writes a key and values map to an env format file.
 *
 * @param string               $file   The path to the env file to write or update.
 * @param array<string,string> $lines  The map of values to write to the env file.
 * @param bool                 $update Whether to update the lines in the file with the new ones, or replace them.
 */
function write_env_file( $file, array $lines = [], $update = false ) {
	$existing_lines = [];

	if ( $update && file_exists( $file ) ) {
		$existing_lines = read_env_file( $file );
	}

	$new_lines = array_merge( $existing_lines, $lines );

	$data = implode( "\n", array_map( static function ( $key, $value ) {
		return "{$key}={$value}";
	}, array_keys( $new_lines ), $new_lines ) );

	$put = file_put_contents( $file, $data );

	if ( false === $put ) {
		echo "\nCould not write env file {$file}";
		exit( 1 );
	}
}

/**
 * Parses an env format file to return its values.
 *
 * @param string $file The path to the env file to parse.
 *
 * @return \Closure A closure that will take the `$key` and `$default` arguments to fetch a value read from the env
 *                  format file.
 */
function env_file( $file ) {
	$map = read_env_file( $file );

	return static function ( $key, $default ) use ( $map ) {

		return isset( $map[ $key ] ) ? $map[ $key ] : $default;
	};
}

/**
 * Prints a debug message, if CLI_VERBOSITY is not `0`.
 *
 * @param string $message The debug message to print.
 */
function debug( $message ) {
	$verbosity = getenv( 'CLI_VERBOSITY' );
	if ( empty( $verbosity ) ) {
		return;
	}

	echo magenta( "[debug] " . $message );
}

/**
 * Reads the SSH_AUTH_SOCK from environment and tries to provide guidance if not set.
 *
 * @return string The `SSH_AUTH_SOCK` environment variable variable value.
 */
function ssh_auth_sock() {
	$env_ssh_sock = getenv( 'SSH_AUTH_SOCK' );
	if ( ! empty( $env_ssh_sock ) ) {
		debug( 'SSH_AUTH_SOCK read from environment.' . PHP_EOL );

		return $env_ssh_sock;
	}

	echo colorize( "<red>SSH_AUTH_SOCK environment variable is not set!</red>\n" );
	echo colorize( "Read why and how to debug here: <light_cyan>https://developer.github.com/v3/guides/using-ssh-agent-forwarding/</light_cyan>\n" );
	exit( 1 );
}
/**
 * docker-compose wrapper functions.
 */

/**
 * Returns the current Operating System family.
 *
 * @return string The human-readable name of the OS PHP is running on. One of `Linux`, `macOS`, `Windows`, `Solaris`,
 *                `BSD` or `Unknown`.
 */
function os() {
	$map = [
		'win' => 'Windows',
		'dar' => 'macOS',
		'lin' => 'Linux',
		'bsd' => 'BSD',
		'sol' => 'Solaris',
	];

	$key = strtolower( substr( PHP_OS, 0, 3 ) );

	return isset( $map[ $key ] ) ? $map[ $key ] : 'Unknown';
}

/**
 * Curried docker-compose wrapper.
 *
 * @param array<string> $options A list of options to initialize the wrapper.
 *
 * @return \Closure A closure to actually call docker-compose with more arguments.
 */
function docker_compose( array $options = [] ) {
	setup_id();

	$is_ci = is_ci();

	$host_ip = false;
	if ( ! $is_ci && 'Linux' === os() ) {
		$linux_overrides = stack( '-linux-override' );
		if ( file_exists( $linux_overrides ) ) {
			$options = array_merge( [ '-f', $linux_overrides ], $options );
		}
		// If we're running on Linux, then try to fetch the host machine IP using a command.
		$host_ip = host_ip( 'Linux' );
	}

	return static function ( array $command = [] ) use ( $options, $host_ip, $is_ci ) {
		$command = 'docker-compose ' . implode( ' ', $options ) . ' ' . implode( ' ', $command );

		if ( ! empty( $host_ip ) ) {
			// Set the host IP address on Linux machines.
			$command = 'XDH=' . host_ip() . ' ' . $command;
		}

		if ( ! empty( $is_ci ) ) {
			// Disable XDebug in CI context to speed up the builds.
			$command = 'XDE=0 ' . $command;
		}

		return process( $command );
	};
}

/**
 * Returns the file path of the WordPress root directory in the WordPress container.
 *
 * @param string $path The path to append to the WordPress root directory path.
 *
 * @return string The absolute path to a directory or file in the WordPress container.
 */
function wordpress_container_root_dir( $path = '/' ) {
	return '/var/www/html/' . ltrim( $path, '\\/' );
}

/**
 * Sets up and returns a wp-cli pre-process, ready to run wp-cli commands in the stack.
 *
 * @return \Closure The wp-cli pre-process, ready to accept an array of commands to run, the `wp` command is not
 *                 required.
 */
function cli() {
	$service = is_ci() ? 'cli' : 'cli_debug';

	return docker_compose( [ '-f', stack(), 'run', $service, '--allow-root' ] );
}

/**
 * Returns the URL at which the `wordpress` service will be reachable on localhost.
 *
 * Depending on whether the current context is a CI one or not, the URL will vary.
 *
 * @return string The URL at which the `wordpress` service can be reached.
 */
function wordpress_url() {
	if ( is_ci() ) {
		return 'http://tribe.test';
	}

	$config = check_status_or_exit( docker_compose( [ '-f', stack() ] )( [ 'config' ] ) )( 'string_output' );

	preg_match( '/wordpress_debug:.*?ports:.*?(?<port>\\d+):80\\/tcp/us', $config, $m );

	if ( ! isset( $m['port'] ) ) {
		echo "\n<red>Could not read the 'wordpress_debug' service localhost port from the stack " .
		     "configuration:\n" . $config;
		exit( 1 );
	}

	return 'http://localhost:' . (int) $m['port'];
}

/**
 * Returns the stack to run depending on the current run context.
 *
 * @param string $postfix      A postfix to use for the stack file, it will be inserted between the file base name and
 *                             the `.yml` file extension.
 *
 * @return string The path to the docker-compose stack file to run, depending on the run context.
 */
function stack( $postfix = '' ) {
	$dev_dir     = dirname( __DIR__ );
	$test_dir    = $dev_dir . '/test';
	$run_context = run_context();
	switch ( $run_context ) {
		case 'tric';
			$stack = $dev_dir . '/tric-stack' . $postfix . '.yml';
			break;
		default:
		case 'default':
		case 'ci':
			$stack = $test_dir . '/activation-stack' . $postfix . '.yml';
			break;
	}

	return $stack;
}

/**
 * Executes a docker-compose command in real time, printing the output as produced by the command.
 *
 * @param array<string> $options A list of options to initialize the wrapper.
 *
 * @return \Closure A closure that will run the process in real time and return the process exit status.
 */
function docker_compose_realtime( array $options = [] ) {
	setup_id();

	$is_ci = is_ci();

	$host_ip = false;
	if ( ! $is_ci && 'Linux' === os() ) {
		$options = array_merge( [ '-f', stack( '-linux-override' ) ], $options );
		// If we're running on Linux, then try to fetch the host machine IP using a command.
		$host_ip = host_ip( 'Linux' );
	}

	return static function ( array $command = [] ) use ( $options, $host_ip, $is_ci ) {
		$command = 'docker-compose ' . implode( ' ', $options ) . ' ' . implode( ' ', $command );

		if ( ! empty( $host_ip ) ) {
			// Set the host IP address on Linux machines.
			$command = 'XDH=' . host_ip() . ' ' . $command;
		}

		if ( ! empty( $is_ci ) ) {
			// Disable XDebug in CI context to speed up the builds.
			$command = 'XDE=0 ' . $command;
		}

		return process_realtime( $command );
	};
}
/**
 * Interactive shell dedicated wrappers.
 */

/**
 * Executes a wp-cli command in the stack, echoes and returns its output.
 *
 * @param array $command The command to execute, e.g. `['plugin', 'list', '--status=active']`.
 * @param bool  $quiet   Whether to echo the command output or not.
 *
 * @return string The command output.
 */
function wp_cli( array $command = [ 'version' ], $quiet = false ) {
	$output = cli()( $command )( 'string_output' );
	if ( ! $quiet ) {
		echo $output;
	}

	return $output;
}
/**
 * WordPress related functions.
 */

/**
 * Returns a WordPress version, picked at random among the last n.
 *
 * @param int $number_versions How many WordPress versions to choose between.
 *                             The "nightly" version is always added.
 *
 * @return string The randomly picked WordPress version.
 */
function random_wordpress_version( $number_versions = 3 ) {
	$versions = wordpress_fetch_versions();

	// Most recent first.
	$all_versions = array_column( $versions, 'version' );
	// First is auto-update, remove.
	$all_versions = array_slice($all_versions,1);
	// Always add "nightly" on top.
	array_unshift( $all_versions, 'nightly' );

	return $versions[ array_rand( array_slice( $all_versions, 0, $number_versions ), 1 ) ]['version'];
}

/**
 * Fetches the last WordPress versions from the WordPress API.
 *
 * @return array<array> An array of WordPress versions.
 */
function wordpress_fetch_versions() {
	echo "\nFetching WordPress version information...";

	$api      = 'https://api.wordpress.org/core/version-check/1.7/';
	$versions = curl_get( $api );

	$decoded = json_decode( $versions, true );

	if ( false === $decoded ) {
		echo "\nCould not fetch WordPress version information.";
		exit( 1 );
	}

	if ( ! isset( $decoded['offers'] ) ) {
		echo "\nWordPress version information is malformed.";
		exit( 1 );
	}

	$offers = $decoded['offers'];

	return $offers;
}

/**
 * Prepares the WordPress installation installing a specific version of WordPress.
 *
 * The command will use the debug version of the WordPress service when not running in CI context.
 *
 * @param string|null The version of WordPress to install, e.g. `5.3.2` or `nightly`.
 */
function prepare_wordpress( $wordpress_version  = 'nightly' ) {
	$stack          = stack();
	$docker_compose = docker_compose( [ '-f', $stack ] );
	$cli            = docker_compose( [ '-f', $stack, 'run', '--rm', 'cli', '--allow-root' ] );
	$waiter         = docker_compose( [ '-f', $stack, 'run', '--rm', 'waiter' ] );
	$service        = is_ci() ? 'wordpress' : 'wordpress_debug';

	// Start the WordPress container.
	check_status_or_exit( $docker_compose( [ 'up', '-d', $service] ) );

	// Wait for WordPress container to come up.
	check_status_or_wait( $waiter() );
	// The db is available, but it will lag a bit behind, let's give it some time.
	sleep( 3 );

	// Install WordPress when it's up and running.
	$url = wordpress_url();
	check_status_or_exit( $cli( [
		'core',
		'install',
		'--url=' . escapeshellarg( $url ),
		'--title="Activation Tests"',
		'--admin_user=admin',
		'--admin_password=admin',
		'--admin_email=admin@tribe.test',
		'--skip-email',
	] ) );

	// Force the installation of a random WordPress version.
	check_status_or_exit( $cli ( [
		'core',
		'update',
		'--version=' . $wordpress_version,
		'--force',
	] ) );

	if ( ! is_ci() ) {
		// Set the site URL explicitly in the configuration file to avoid URL mangling.
		check_status_or_exit( $cli( [ 'config', 'set', 'WP_SITEURL', escapeshellarg( $url ) ] ) );
		check_status_or_exit( $cli( [ 'config', 'set', 'WP_HOME', escapeshellarg( $url ) ] ) );
		echo "\033[32mWordPress installation available at ${url}\033[0m";
	}
}

echo implode( PHP_EOL, [
	'...the Modern Tribe version.',
	PHP_EOL,
	'You will be able to use any of the functions defined in the repository files.',
	'This is a modified PHP interactive shell, <light_cyan>auto-completion is available.',
	PHP_EOL
] );

